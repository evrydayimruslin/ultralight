/**
 * Ultralight SDK
 *
 * TypeScript SDK for programmatic access to Ultralight platform.
 *
 * @example
 * ```typescript
 * import { Ultralight } from 'https://ultralight.dev/sdk/mod.ts';
 *
 * const ul = new Ultralight({ token: 'your-token' });
 *
 * // List apps
 * const apps = await ul.apps.list();
 *
 * // Create an app
 * const app = await ul.apps.create({
 *   name: 'My App',
 *   files: [{ path: 'index.ts', content: 'export function hello() { return "Hello!"; }' }]
 * });
 *
 * // Run a function
 * const result = await ul.run(app.app_id, 'hello');
 * ```
 */

export interface UltralightConfig {
  /** API base URL (default: https://ultralight.dev) */
  apiUrl?: string;
  /** Authentication token (JWT or API key) */
  token: string;
}

export interface CreateAppOptions {
  name?: string;
  slug?: string;
  description?: string;
  visibility?: 'private' | 'unlisted' | 'public';
  files: Array<{
    path: string;
    content: string;
    encoding?: 'text' | 'base64';
  }>;
  autoGenerateDocs?: boolean;
}

export interface UpdateAppOptions {
  name?: string;
  description?: string;
  visibility?: 'private' | 'unlisted' | 'public';
  category?: string;
  tags?: string[];
}

export interface ListAppsOptions {
  visibility?: 'all' | 'public' | 'private' | 'unlisted';
  limit?: number;
  offset?: number;
  includeDrafts?: boolean;
}

export interface DraftUploadOptions {
  files: Array<{
    path: string;
    content: string;
    encoding?: 'text' | 'base64';
  }>;
}

export interface PublishOptions {
  regenerateDocs?: boolean;
  versionBump?: 'patch' | 'minor' | 'major';
}

export interface DiscoverOptions {
  limit?: number;
  includePrivate?: boolean;
  minSimilarity?: number;
}

export interface RunOptions {
  useDraft?: boolean;
}

export interface App {
  id: string;
  slug: string;
  name: string;
  description: string | null;
  visibility: 'private' | 'unlisted' | 'public';
  current_version: string;
  exports: string[];
  total_runs: number;
  runs_30d: number;
  mcp_endpoint: string;
  app_url: string;
  created_at: string;
  updated_at: string;
}

export interface RunResult {
  success: boolean;
  result: unknown;
  error?: string;
  logs?: Array<{ message: string }>;
  duration_ms: number;
}

export interface DiscoverResult {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  similarity: number;
  is_owner: boolean;
  mcp_endpoint: string;
}

/**
 * Main Ultralight SDK client
 */
export class Ultralight {
  private apiUrl: string;
  private token: string;
  private requestId = 0;

  /** App management methods */
  readonly apps: AppsClient;
  /** Draft management methods */
  readonly drafts: DraftsClient;
  /** Documentation methods */
  readonly docs: DocsClient;

  constructor(config: UltralightConfig) {
    this.apiUrl = config.apiUrl || 'https://ultralight.dev';
    this.token = config.token;

    this.apps = new AppsClient(this);
    this.drafts = new DraftsClient(this);
    this.docs = new DocsClient(this);
  }

  /**
   * Execute a function in an app
   */
  async run(appId: string, functionName: string, args?: unknown, options?: RunOptions): Promise<RunResult> {
    return this.callTool('platform.run', {
      app_id: appId,
      function: functionName,
      args,
      use_draft: options?.useDraft,
    }) as Promise<RunResult>;
  }

  /**
   * Discover apps by capability
   */
  async discover(query: string, options?: DiscoverOptions): Promise<DiscoverResult[]> {
    const result = await this.callTool('platform.discover', {
      query,
      limit: options?.limit,
      include_private: options?.includePrivate,
      min_similarity: options?.minSimilarity,
    });
    return (result as { results: DiscoverResult[] }).results;
  }

  /**
   * Get current user profile
   */
  async getUser(): Promise<{
    id: string;
    email: string;
    display_name: string | null;
    tier: string;
  }> {
    return this.callTool('platform.user.profile', {}) as Promise<{
      id: string;
      email: string;
      display_name: string | null;
      tier: string;
    }>;
  }

  /**
   * Create an MCP client for a specific app
   */
  mcp(appId: string): McpClient {
    return new McpClient(this.apiUrl, this.token, appId);
  }

  /**
   * Internal: Call a platform MCP tool
   */
  async callTool(name: string, args: Record<string, unknown>): Promise<unknown> {
    const response = await fetch(`${this.apiUrl}/mcp/platform`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: ++this.requestId,
        method: 'tools/call',
        params: { name, arguments: args },
      }),
    });

    if (!response.ok) {
      throw new UltralightError(`API error: ${response.status}`, response.status);
    }

    const rpc = await response.json();

    if (rpc.error) {
      throw new UltralightError(rpc.error.message, rpc.error.code);
    }

    if (rpc.result?.isError) {
      throw new UltralightError(rpc.result.content?.[0]?.text || 'Unknown error');
    }

    return rpc.result?.structuredContent ?? {};
  }
}

/**
 * Apps client
 */
class AppsClient {
  constructor(private client: Ultralight) {}

  /**
   * List apps
   */
  async list(options?: ListAppsOptions): Promise<{ apps: App[]; total: number }> {
    return this.client.callTool('platform.apps.list', {
      visibility: options?.visibility,
      limit: options?.limit,
      offset: options?.offset,
      include_drafts: options?.includeDrafts,
    }) as Promise<{ apps: App[]; total: number }>;
  }

  /**
   * Get app details
   */
  async get(appId: string, options?: { includeCode?: boolean; includeSkills?: boolean }): Promise<App & { code?: string; skills_md?: string }> {
    return this.client.callTool('platform.apps.get', {
      app_id: appId,
      include_code: options?.includeCode,
      include_skills: options?.includeSkills,
    }) as Promise<App & { code?: string; skills_md?: string }>;
  }

  /**
   * Create a new app
   */
  async create(options: CreateAppOptions): Promise<{
    app_id: string;
    slug: string;
    version: string;
    url: string;
    exports: string[];
    docs_generated?: boolean;
  }> {
    return this.client.callTool('platform.apps.create', {
      name: options.name,
      slug: options.slug,
      description: options.description,
      visibility: options.visibility,
      auto_generate_docs: options.autoGenerateDocs,
      files: options.files,
    }) as Promise<{
      app_id: string;
      slug: string;
      version: string;
      url: string;
      exports: string[];
      docs_generated?: boolean;
    }>;
  }

  /**
   * Update app metadata
   */
  async update(appId: string, updates: UpdateAppOptions): Promise<{ success: boolean }> {
    return this.client.callTool('platform.apps.update', {
      app_id: appId,
      ...updates,
    }) as Promise<{ success: boolean }>;
  }

  /**
   * Delete an app
   */
  async delete(appId: string): Promise<{ success: boolean }> {
    return this.client.callTool('platform.apps.delete', {
      app_id: appId,
      confirm: true,
    }) as Promise<{ success: boolean }>;
  }

  /**
   * Search apps by text
   */
  async search(query: string, options?: { limit?: number; offset?: number }): Promise<{ results: App[]; total: number }> {
    return this.client.callTool('platform.apps.search', {
      query,
      limit: options?.limit,
      offset: options?.offset,
    }) as Promise<{ results: App[]; total: number }>;
  }
}

/**
 * Drafts client
 */
class DraftsClient {
  constructor(private client: Ultralight) {}

  /**
   * Upload a draft
   */
  async upload(appId: string, options: DraftUploadOptions): Promise<{
    app_id: string;
    draft_version: string;
    exports: string[];
  }> {
    return this.client.callTool('platform.draft.upload', {
      app_id: appId,
      files: options.files,
    }) as Promise<{
      app_id: string;
      draft_version: string;
      exports: string[];
    }>;
  }

  /**
   * Get draft status
   */
  async get(appId: string, options?: { includeDiff?: boolean }): Promise<{
    has_draft: boolean;
    draft_version?: string;
    draft_uploaded_at?: string;
    exports_diff?: {
      added: string[];
      removed: string[];
    };
  }> {
    return this.client.callTool('platform.draft.get', {
      app_id: appId,
      include_diff: options?.includeDiff,
    }) as Promise<{
      has_draft: boolean;
      draft_version?: string;
      draft_uploaded_at?: string;
      exports_diff?: { added: string[]; removed: string[] };
    }>;
  }

  /**
   * Publish a draft
   */
  async publish(appId: string, options?: PublishOptions): Promise<{
    success: boolean;
    previous_version: string;
    new_version: string;
    docs_regenerated: boolean;
  }> {
    return this.client.callTool('platform.draft.publish', {
      app_id: appId,
      regenerate_docs: options?.regenerateDocs,
      version_bump: options?.versionBump,
    }) as Promise<{
      success: boolean;
      previous_version: string;
      new_version: string;
      docs_regenerated: boolean;
    }>;
  }

  /**
   * Discard a draft
   */
  async discard(appId: string): Promise<{ success: boolean }> {
    return this.client.callTool('platform.draft.discard', {
      app_id: appId,
    }) as Promise<{ success: boolean }>;
  }
}

/**
 * Docs client
 */
class DocsClient {
  constructor(private client: Ultralight) {}

  /**
   * Generate documentation
   */
  async generate(appId: string, options?: { aiEnhance?: boolean }): Promise<{
    success: boolean;
    functions_found: number;
    embedding_generated: boolean;
  }> {
    return this.client.callTool('platform.docs.generate', {
      app_id: appId,
      ai_enhance: options?.aiEnhance,
    }) as Promise<{
      success: boolean;
      functions_found: number;
      embedding_generated: boolean;
    }>;
  }

  /**
   * Get documentation
   */
  async get(appId: string, format?: 'markdown' | 'json' | 'mcp'): Promise<{
    exists: boolean;
    skills_md?: string;
    skills_parsed?: unknown;
    tools?: unknown[];
  }> {
    return this.client.callTool('platform.docs.get', {
      app_id: appId,
      format,
    }) as Promise<{
      exists: boolean;
      skills_md?: string;
      skills_parsed?: unknown;
      tools?: unknown[];
    }>;
  }

  /**
   * Update documentation
   */
  async update(appId: string, skillsMd: string): Promise<{
    success: boolean;
    functions_found: number;
    warnings: string[];
  }> {
    return this.client.callTool('platform.docs.update', {
      app_id: appId,
      skills_md: skillsMd,
    }) as Promise<{
      success: boolean;
      functions_found: number;
      warnings: string[];
    }>;
  }
}

/**
 * MCP client for app-specific tools
 */
class McpClient {
  private requestId = 0;

  constructor(
    private apiUrl: string,
    private token: string,
    private appId: string
  ) {}

  /**
   * List available tools
   */
  async listTools(): Promise<Array<{
    name: string;
    description: string;
    inputSchema: unknown;
  }>> {
    const response = await this.request('tools/list', {});
    return (response as { tools: Array<{ name: string; description: string; inputSchema: unknown }> }).tools;
  }

  /**
   * Call a tool
   */
  async callTool(name: string, args: Record<string, unknown>): Promise<unknown> {
    const response = await this.request('tools/call', {
      name,
      arguments: args,
    });

    if ((response as { isError?: boolean }).isError) {
      throw new UltralightError((response as { content?: Array<{ text?: string }> }).content?.[0]?.text || 'Tool error');
    }

    return (response as { structuredContent?: unknown }).structuredContent;
  }

  private async request(method: string, params: Record<string, unknown>): Promise<unknown> {
    const response = await fetch(`${this.apiUrl}/mcp/${this.appId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: ++this.requestId,
        method,
        params,
      }),
    });

    if (!response.ok) {
      throw new UltralightError(`API error: ${response.status}`, response.status);
    }

    const rpc = await response.json();

    if (rpc.error) {
      throw new UltralightError(rpc.error.message, rpc.error.code);
    }

    return rpc.result;
  }
}

/**
 * Custom error class
 */
export class UltralightError extends Error {
  constructor(message: string, public code?: number) {
    super(message);
    this.name = 'UltralightError';
  }
}

// Default export
export default Ultralight;
